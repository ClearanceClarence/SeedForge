<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SeedForge Test Suite</title>
    <style>
        :root {
            --bg: #0d1117;
            --surface: #161b22;
            --border: #30363d;
            --text: #c9d1d9;
            --text-muted: #8b949e;
            --accent: #58a6ff;
            --success: #3fb950;
            --error: #f85149;
            --warning: #d29922;
        }
        
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }
        
        body {
            font-family: 'Segoe UI', -apple-system, BlinkMacSystemFont, sans-serif;
            background: var(--bg);
            color: var(--text);
            line-height: 1.6;
            padding: 20px;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
        }
        
        header {
            text-align: center;
            margin-bottom: 30px;
            padding-bottom: 20px;
            border-bottom: 1px solid var(--border);
        }
        
        h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
            background: linear-gradient(135deg, #58a6ff, #a371f7);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }
        
        .subtitle {
            color: var(--text-muted);
            font-size: 1.1rem;
        }
        
        .controls {
            display: flex;
            gap: 15px;
            justify-content: center;
            margin-bottom: 30px;
            flex-wrap: wrap;
        }
        
        .control-group {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        label {
            color: var(--text-muted);
            font-size: 0.9rem;
        }
        
        input[type="text"], select {
            background: var(--surface);
            border: 1px solid var(--border);
            color: var(--text);
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 0.95rem;
        }
        
        input[type="text"]:focus, select:focus {
            outline: none;
            border-color: var(--accent);
        }
        
        button {
            background: var(--accent);
            color: #fff;
            border: none;
            padding: 10px 20px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 0.95rem;
            font-weight: 500;
            transition: opacity 0.2s;
        }
        
        button:hover {
            opacity: 0.9;
        }
        
        .test-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(400px, 1fr));
            gap: 20px;
        }
        
        .test-section {
            background: var(--surface);
            border: 1px solid var(--border);
            border-radius: 10px;
            overflow: hidden;
        }
        
        .section-header {
            background: rgba(88, 166, 255, 0.1);
            padding: 12px 16px;
            border-bottom: 1px solid var(--border);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .section-header h2 {
            font-size: 1rem;
            font-weight: 600;
        }
        
        .section-status {
            font-size: 0.8rem;
            padding: 3px 8px;
            border-radius: 4px;
            font-weight: 500;
        }
        
        .status-pass {
            background: rgba(63, 185, 80, 0.2);
            color: var(--success);
        }
        
        .status-fail {
            background: rgba(248, 81, 73, 0.2);
            color: var(--error);
        }
        
        .section-content {
            padding: 16px;
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 0.85rem;
            max-height: 300px;
            overflow-y: auto;
        }
        
        .log-line {
            padding: 4px 0;
            border-bottom: 1px solid var(--border);
        }
        
        .log-line:last-child {
            border-bottom: none;
        }
        
        .log-pass {
            color: var(--success);
        }
        
        .log-fail {
            color: var(--error);
        }
        
        .log-info {
            color: var(--text-muted);
        }
        
        .log-value {
            color: var(--accent);
        }
        
        .visual-section {
            grid-column: 1 / -1;
        }
        
        .visual-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            padding: 16px;
        }
        
        .visual-item {
            text-align: center;
        }
        
        .visual-item h3 {
            font-size: 0.9rem;
            margin-bottom: 10px;
            color: var(--text-muted);
        }
        
        canvas {
            background: var(--bg);
            border-radius: 6px;
            display: block;
            margin: 0 auto;
        }
        
        .histogram {
            display: flex;
            align-items: flex-end;
            justify-content: center;
            height: 150px;
            gap: 2px;
            padding: 10px;
        }
        
        .histogram-bar {
            width: 8px;
            background: var(--accent);
            border-radius: 2px 2px 0 0;
            transition: height 0.3s;
        }
        
        .summary {
            text-align: center;
            padding: 20px;
            margin-top: 20px;
            background: var(--surface);
            border-radius: 10px;
            border: 1px solid var(--border);
        }
        
        .summary-stats {
            display: flex;
            justify-content: center;
            gap: 40px;
            margin-top: 15px;
        }
        
        .stat {
            text-align: center;
        }
        
        .stat-value {
            font-size: 2rem;
            font-weight: bold;
        }
        
        .stat-label {
            color: var(--text-muted);
            font-size: 0.9rem;
        }
        
        .stat-pass .stat-value { color: var(--success); }
        .stat-fail .stat-value { color: var(--error); }
        .stat-total .stat-value { color: var(--accent); }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>üå± SeedForge Test Suite</h1>
            <p class="subtitle">Advanced PRNG Library - Interactive Testing</p>
        </header>
        
        <div class="controls">
            <div class="control-group">
                <label for="seed">Seed:</label>
                <input type="text" id="seed" value="test-seed-42" placeholder="Enter seed...">
            </div>
            <div class="control-group">
                <label for="algorithm">Algorithm:</label>
                <select id="algorithm">
                    <option value="xoshiro128">Xoshiro128** (default)</option>
                    <option value="sfc32">SFC32</option>
                    <option value="pcg32">PCG32</option>
                    <option value="mulberry32">Mulberry32</option>
                    <option value="xorshift128">Xorshift128+</option>
                    <option value="lcg">LCG</option>
                </select>
            </div>
            <button onclick="runAllTests()">‚ñ∂ Run All Tests</button>
            <button onclick="clearResults()" style="background: var(--border);">Clear</button>
        </div>
        
        <div class="test-grid" id="testGrid">
            <!-- Test sections will be inserted here -->
        </div>
        
        <div class="summary" id="summary" style="display: none;">
            <h2>Test Summary</h2>
            <div class="summary-stats">
                <div class="stat stat-pass">
                    <div class="stat-value" id="passCount">0</div>
                    <div class="stat-label">Passed</div>
                </div>
                <div class="stat stat-fail">
                    <div class="stat-value" id="failCount">0</div>
                    <div class="stat-label">Failed</div>
                </div>
                <div class="stat stat-total">
                    <div class="stat-value" id="totalCount">0</div>
                    <div class="stat-label">Total</div>
                </div>
            </div>
        </div>
    </div>
    
    <script src="../dist/seedforge.js"></script>
    <script>
        // Test framework
        let testResults = { passed: 0, failed: 0 };
        
        function createSection(id, title) {
            const section = document.createElement('div');
            section.className = 'test-section';
            section.id = id;
            section.innerHTML = `
                <div class="section-header">
                    <h2>${title}</h2>
                    <span class="section-status" id="${id}-status">Running...</span>
                </div>
                <div class="section-content" id="${id}-content"></div>
            `;
            document.getElementById('testGrid').appendChild(section);
            return document.getElementById(`${id}-content`);
        }
        
        function log(container, message, type = 'info') {
            const line = document.createElement('div');
            line.className = `log-line log-${type}`;
            line.innerHTML = message;
            container.appendChild(line);
        }
        
        function assert(container, condition, message) {
            if (condition) {
                log(container, `‚úÖ ${message}`, 'pass');
                testResults.passed++;
                return true;
            } else {
                log(container, `‚ùå ${message}`, 'fail');
                testResults.failed++;
                return false;
            }
        }
        
        function setStatus(id, passed) {
            const status = document.getElementById(`${id}-status`);
            status.className = `section-status ${passed ? 'status-pass' : 'status-fail'}`;
            status.textContent = passed ? 'PASS' : 'FAIL';
        }
        
        function getSeed() {
            return document.getElementById('seed').value || 'default-seed';
        }
        
        function getAlgorithm() {
            return document.getElementById('algorithm').value;
        }
        
        function clearResults() {
            document.getElementById('testGrid').innerHTML = '';
            document.getElementById('summary').style.display = 'none';
            testResults = { passed: 0, failed: 0 };
        }
        
        // ============================================================
        // TESTS
        // ============================================================
        
        function testBasicGeneration() {
            const container = createSection('basic', 'üé≤ Basic Generation');
            const seed = getSeed();
            const algo = getAlgorithm();
            let allPassed = true;
            
            try {
                const rng = new PRNG.PRNG(seed, algo);
                
                log(container, `Seed: <span class="log-value">${seed}</span>, Algorithm: <span class="log-value">${algo}</span>`);
                
                // Test random() range
                let inRange = true;
                for (let i = 0; i < 1000; i++) {
                    const v = rng.random();
                    if (v < 0 || v >= 1) inRange = false;
                }
                allPassed &= assert(container, inRange, 'random() returns values in [0, 1)');
                
                // Test int() range
                rng.reset();
                let intInRange = true;
                for (let i = 0; i < 1000; i++) {
                    const v = rng.int(5, 15);
                    if (v < 5 || v > 15 || !Number.isInteger(v)) intInRange = false;
                }
                allPassed &= assert(container, intInRange, 'int(5, 15) returns integers in [5, 15]');
                
                // Test float() range
                rng.reset();
                let floatInRange = true;
                for (let i = 0; i < 1000; i++) {
                    const v = rng.float(10, 20);
                    if (v < 10 || v >= 20) floatInRange = false;
                }
                allPassed &= assert(container, floatInRange, 'float(10, 20) returns values in [10, 20)');
                
                // Test bool()
                rng.reset();
                let trueCount = 0;
                for (let i = 0; i < 10000; i++) {
                    if (rng.bool(0.3)) trueCount++;
                }
                const ratio = trueCount / 10000;
                allPassed &= assert(container, ratio > 0.25 && ratio < 0.35, `bool(0.3) ~30% true (got ${(ratio * 100).toFixed(1)}%)`);
                
                // Show sample values
                rng.reset();
                const samples = [];
                for (let i = 0; i < 5; i++) samples.push(rng.random().toFixed(6));
                log(container, `Sample values: <span class="log-value">[${samples.join(', ')}]</span>`);
                
            } catch (e) {
                log(container, `Error: ${e.message}`, 'fail');
                allPassed = false;
            }
            
            setStatus('basic', allPassed);
        }
        
        function testReproducibility() {
            const container = createSection('repro', 'üîÑ Reproducibility');
            const seed = getSeed();
            const algo = getAlgorithm();
            let allPassed = true;
            
            try {
                const rng1 = new PRNG.PRNG(seed, algo);
                const rng2 = new PRNG.PRNG(seed, algo);
                
                const seq1 = [];
                const seq2 = [];
                for (let i = 0; i < 10; i++) {
                    seq1.push(rng1.random());
                    seq2.push(rng2.random());
                }
                
                const identical = seq1.every((v, i) => v === seq2[i]);
                allPassed &= assert(container, identical, 'Same seed produces identical sequences');
                
                log(container, `Sequence 1: <span class="log-value">[${seq1.slice(0, 3).map(v => v.toFixed(4)).join(', ')}...]</span>`);
                log(container, `Sequence 2: <span class="log-value">[${seq2.slice(0, 3).map(v => v.toFixed(4)).join(', ')}...]</span>`);
                
                // Test reset
                rng1.reset();
                const afterReset = [];
                for (let i = 0; i < 10; i++) {
                    afterReset.push(rng1.random());
                }
                const resetWorks = seq1.every((v, i) => v === afterReset[i]);
                allPassed &= assert(container, resetWorks, 'reset() returns to initial state');
                
                // Test different seeds
                const rng3 = new PRNG.PRNG(seed + '-different', algo);
                const seq3 = [];
                for (let i = 0; i < 10; i++) {
                    seq3.push(rng3.random());
                }
                const different = !seq1.every((v, i) => v === seq3[i]);
                allPassed &= assert(container, different, 'Different seeds produce different sequences');
                
            } catch (e) {
                log(container, `Error: ${e.message}`, 'fail');
                allPassed = false;
            }
            
            setStatus('repro', allPassed);
        }
        
        function testStateManagement() {
            const container = createSection('state', 'üíæ State Management');
            const seed = getSeed();
            const algo = getAlgorithm();
            let allPassed = true;
            
            try {
                const rng = new PRNG.PRNG(seed, algo);
                
                // Advance the generator
                for (let i = 0; i < 50; i++) rng.random();
                
                // Save state
                const savedState = rng.getState();
                log(container, `State saved after 50 iterations`);
                
                // Generate more values
                const expected = [];
                for (let i = 0; i < 10; i++) {
                    expected.push(rng.random());
                }
                
                // Restore and verify
                rng.setState(savedState);
                const restored = [];
                for (let i = 0; i < 10; i++) {
                    restored.push(rng.random());
                }
                
                const stateWorks = expected.every((v, i) => v === restored[i]);
                allPassed &= assert(container, stateWorks, 'setState() restores exact position');
                
                // Test clone
                rng.reset();
                for (let i = 0; i < 25; i++) rng.random();
                
                const cloned = rng.clone();
                const origSeq = [];
                const cloneSeq = [];
                for (let i = 0; i < 10; i++) {
                    origSeq.push(rng.random());
                    cloneSeq.push(cloned.random());
                }
                
                const cloneWorks = origSeq.every((v, i) => v === cloneSeq[i]);
                allPassed &= assert(container, cloneWorks, 'clone() creates independent copy');
                
                // Test fork
                rng.reset();
                const fork1 = rng.fork('terrain');
                const fork2 = rng.fork('rivers');
                
                const forkVal1 = fork1.random();
                const forkVal2 = fork2.random();
                allPassed &= assert(container, forkVal1 !== forkVal2, 'fork() creates different streams');
                
                // Verify fork reproducibility
                const rng2 = new PRNG.PRNG(seed, algo);
                const fork1Again = rng2.fork('terrain');
                allPassed &= assert(container, fork1Again.random() === forkVal1, 'fork() is reproducible');
                
            } catch (e) {
                log(container, `Error: ${e.message}`, 'fail');
                allPassed = false;
            }
            
            setStatus('state', allPassed);
        }
        
        function testDistributions() {
            const container = createSection('dist', 'üìä Statistical Distributions');
            const seed = getSeed();
            const algo = getAlgorithm();
            let allPassed = true;
            
            try {
                const rng = new PRNG.PRNG(seed, algo);
                const n = 10000;
                
                // Normal distribution
                const normals = [];
                for (let i = 0; i < n; i++) normals.push(rng.normal(100, 15));
                const normalMean = normals.reduce((a, b) => a + b, 0) / n;
                const normalStd = Math.sqrt(normals.reduce((a, b) => a + (b - normalMean) ** 2, 0) / n);
                
                allPassed &= assert(container, Math.abs(normalMean - 100) < 1, 
                    `normal(100, 15) mean: ${normalMean.toFixed(2)} (expected ~100)`);
                allPassed &= assert(container, Math.abs(normalStd - 15) < 1, 
                    `normal(100, 15) stdDev: ${normalStd.toFixed(2)} (expected ~15)`);
                
                // Exponential distribution
                const exps = [];
                for (let i = 0; i < n; i++) exps.push(rng.exponential(0.5));
                const expMean = exps.reduce((a, b) => a + b, 0) / n;
                allPassed &= assert(container, Math.abs(expMean - 2) < 0.1, 
                    `exponential(0.5) mean: ${expMean.toFixed(2)} (expected ~2)`);
                
                // Poisson distribution
                const poissons = [];
                for (let i = 0; i < n; i++) poissons.push(rng.poisson(4));
                const poissonMean = poissons.reduce((a, b) => a + b, 0) / n;
                allPassed &= assert(container, Math.abs(poissonMean - 4) < 0.2, 
                    `poisson(4) mean: ${poissonMean.toFixed(2)} (expected ~4)`);
                
                // Triangular distribution
                const triangulars = [];
                for (let i = 0; i < n; i++) triangulars.push(rng.triangular(0, 10, 7));
                const triMean = triangulars.reduce((a, b) => a + b, 0) / n;
                const expectedTriMean = (0 + 10 + 7) / 3; // 5.67
                allPassed &= assert(container, Math.abs(triMean - expectedTriMean) < 0.2, 
                    `triangular(0, 10, 7) mean: ${triMean.toFixed(2)} (expected ~${expectedTriMean.toFixed(2)})`);
                
            } catch (e) {
                log(container, `Error: ${e.message}`, 'fail');
                allPassed = false;
            }
            
            setStatus('dist', allPassed);
        }
        
        function testArrayUtilities() {
            const container = createSection('array', 'üì¶ Array Utilities');
            const seed = getSeed();
            const algo = getAlgorithm();
            let allPassed = true;
            
            try {
                const rng = new PRNG.PRNG(seed, algo);
                
                // Shuffle
                const original = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
                const shuffled = rng.shuffled(original);
                
                const originalUnchanged = original.join(',') === '1,2,3,4,5,6,7,8,9,10';
                allPassed &= assert(container, originalUnchanged, 'shuffled() does not modify original');
                
                const sameElements = shuffled.slice().sort((a, b) => a - b).join(',') === original.join(',');
                allPassed &= assert(container, sameElements, 'shuffled() contains same elements');
                
                log(container, `Shuffled: <span class="log-value">[${shuffled.join(', ')}]</span>`);
                
                // Pick
                const items = ['apple', 'banana', 'cherry', 'date', 'elderberry'];
                const picked = rng.pick(items);
                allPassed &= assert(container, items.includes(picked), `pick() returns valid item: ${picked}`);
                
                // Sample
                const sampled = rng.sample(items, 3);
                allPassed &= assert(container, sampled.length === 3, 'sample(3) returns 3 items');
                allPassed &= assert(container, new Set(sampled).size === 3, 'sample() returns unique items');
                log(container, `Sample(3): <span class="log-value">[${sampled.join(', ')}]</span>`);
                
                // Weighted pick
                const weights = { common: 70, uncommon: 20, rare: 8, legendary: 2 };
                const counts = { common: 0, uncommon: 0, rare: 0, legendary: 0 };
                for (let i = 0; i < 10000; i++) {
                    counts[rng.weightedPickObject(weights)]++;
                }
                
                allPassed &= assert(container, counts.common > counts.uncommon, 
                    `Weighted: common(${counts.common}) > uncommon(${counts.uncommon})`);
                allPassed &= assert(container, counts.uncommon > counts.rare, 
                    `Weighted: uncommon(${counts.uncommon}) > rare(${counts.rare})`);
                allPassed &= assert(container, counts.rare > counts.legendary, 
                    `Weighted: rare(${counts.rare}) > legendary(${counts.legendary})`);
                
            } catch (e) {
                log(container, `Error: ${e.message}`, 'fail');
                allPassed = false;
            }
            
            setStatus('array', allPassed);
        }
        
        function testGeometric() {
            const container = createSection('geo', 'üìê Geometric Utilities');
            const seed = getSeed();
            const algo = getAlgorithm();
            let allPassed = true;
            
            try {
                const rng = new PRNG.PRNG(seed, algo);
                
                // Point in circle
                let allInCircle = true;
                for (let i = 0; i < 1000; i++) {
                    const p = rng.pointInCircle(10);
                    const dist = Math.sqrt(p.x ** 2 + p.y ** 2);
                    if (dist > 10) allInCircle = false;
                }
                allPassed &= assert(container, allInCircle, 'pointInCircle(10) always within radius');
                
                // Point on circle
                let allOnCircle = true;
                for (let i = 0; i < 100; i++) {
                    const p = rng.pointOnCircle(5);
                    const dist = Math.sqrt(p.x ** 2 + p.y ** 2);
                    if (Math.abs(dist - 5) > 0.0001) allOnCircle = false;
                }
                allPassed &= assert(container, allOnCircle, 'pointOnCircle(5) always on edge');
                
                // Point in sphere
                let allInSphere = true;
                for (let i = 0; i < 1000; i++) {
                    const p = rng.pointInSphere(1);
                    const dist = Math.sqrt(p.x ** 2 + p.y ** 2 + p.z ** 2);
                    if (dist > 1) allInSphere = false;
                }
                allPassed &= assert(container, allInSphere, 'pointInSphere(1) always within radius');
                
                // Point in rect
                let allInRect = true;
                for (let i = 0; i < 1000; i++) {
                    const p = rng.pointInRect(10, 20, 100, 50);
                    if (p.x < 10 || p.x >= 110 || p.y < 20 || p.y >= 70) allInRect = false;
                }
                allPassed &= assert(container, allInRect, 'pointInRect() always within bounds');
                
                // Direction vectors
                const dir2d = rng.direction2D();
                const len2d = Math.sqrt(dir2d.x ** 2 + dir2d.y ** 2);
                allPassed &= assert(container, Math.abs(len2d - 1) < 0.0001, 
                    `direction2D() is unit vector (len=${len2d.toFixed(4)})`);
                
                const dir3d = rng.direction3D();
                const len3d = Math.sqrt(dir3d.x ** 2 + dir3d.y ** 2 + dir3d.z ** 2);
                allPassed &= assert(container, Math.abs(len3d - 1) < 0.0001, 
                    `direction3D() is unit vector (len=${len3d.toFixed(4)})`);
                
            } catch (e) {
                log(container, `Error: ${e.message}`, 'fail');
                allPassed = false;
            }
            
            setStatus('geo', allPassed);
        }
        
        function testSpecialGenerators() {
            const container = createSection('special', '‚ú® Special Generators');
            const seed = getSeed();
            const algo = getAlgorithm();
            let allPassed = true;
            
            try {
                const rng = new PRNG.PRNG(seed, algo);
                
                // UUID
                const uuid = rng.uuid();
                const uuidRegex = /^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/;
                allPassed &= assert(container, uuidRegex.test(uuid), `uuid() format valid: ${uuid}`);
                
                // Unique UUIDs
                const uuids = new Set();
                for (let i = 0; i < 100; i++) uuids.add(rng.uuid());
                allPassed &= assert(container, uuids.size === 100, 'uuid() generates unique values');
                
                // Color
                const color = rng.color();
                const colorRegex = /^#[0-9a-f]{6}$/;
                allPassed &= assert(container, colorRegex.test(color), `color() format valid: ${color}`);
                
                // RGB
                const rgb = rng.colorRGB();
                allPassed &= assert(container, 
                    rgb.r >= 0 && rgb.r <= 255 && rgb.g >= 0 && rgb.g <= 255 && rgb.b >= 0 && rgb.b <= 255,
                    `colorRGB() valid: rgb(${rgb.r}, ${rgb.g}, ${rgb.b})`);
                
                // HSL
                const hsl = rng.colorHSL();
                allPassed &= assert(container, 
                    hsl.h >= 0 && hsl.h <= 360 && hsl.s >= 0 && hsl.s <= 100 && hsl.l >= 0 && hsl.l <= 100,
                    `colorHSL() valid: hsl(${hsl.h}, ${hsl.s}%, ${hsl.l}%)`);
                
                // String
                const str = rng.string(16);
                allPassed &= assert(container, str.length === 16, `string(16) correct length: "${str}"`);
                
                const hexStr = rng.string(8, '0123456789abcdef');
                allPassed &= assert(container, /^[0-9a-f]{8}$/.test(hexStr), `hex string valid: "${hexStr}"`);
                
            } catch (e) {
                log(container, `Error: ${e.message}`, 'fail');
                allPassed = false;
            }
            
            setStatus('special', allPassed);
        }
        
        function testNoise() {
            const container = createSection('noise', 'üåä Noise Generators');
            const seed = getSeed();
            let allPassed = true;
            
            try {
                // Value Noise
                const valueNoise = new PRNG.Noise.ValueNoise(seed);
                
                let valueInRange = true;
                for (let i = 0; i < 100; i++) {
                    const v = valueNoise.noise2D(i * 0.1, i * 0.05);
                    if (v < 0 || v > 1) valueInRange = false;
                }
                allPassed &= assert(container, valueInRange, 'ValueNoise.noise2D() in [0, 1]');
                
                // Continuity test (nearby points should be similar)
                const v1 = valueNoise.noise2D(1.0, 1.0);
                const v2 = valueNoise.noise2D(1.01, 1.0);
                allPassed &= assert(container, Math.abs(v1 - v2) < 0.1, 
                    `ValueNoise is continuous (${v1.toFixed(3)} ‚âà ${v2.toFixed(3)})`);
                
                // Simplex Noise
                const simplex = new PRNG.Noise.SimplexNoise(seed);
                
                let simplexInRange = true;
                for (let i = 0; i < 100; i++) {
                    const v = simplex.noise2D(i * 0.1, i * 0.05);
                    if (v < -1 || v > 1) simplexInRange = false;
                }
                allPassed &= assert(container, simplexInRange, 'SimplexNoise.noise2D() in [-1, 1]');
                
                // fBm
                const fbmValue = valueNoise.fbm(1.5, 2.5, null, 4, 2.0, 0.5);
                allPassed &= assert(container, typeof fbmValue === 'number' && !isNaN(fbmValue), 
                    `fBm works: ${fbmValue.toFixed(4)}`);
                
                // Reproducibility
                const noise1 = new PRNG.Noise.ValueNoise(seed);
                const noise2 = new PRNG.Noise.ValueNoise(seed);
                const n1 = noise1.noise2D(5.5, 3.2);
                const n2 = noise2.noise2D(5.5, 3.2);
                allPassed &= assert(container, n1 === n2, 'Noise is reproducible with same seed');
                
            } catch (e) {
                log(container, `Error: ${e.message}`, 'fail');
                allPassed = false;
            }
            
            setStatus('noise', allPassed);
        }
        
        function testAllAlgorithms() {
            const container = createSection('algos', '‚öôÔ∏è All Algorithms');
            const seed = getSeed();
            let allPassed = true;
            
            const algorithms = ['mulberry32', 'xoshiro128', 'xorshift128', 'pcg32', 'sfc32', 'lcg'];
            
            for (const algo of algorithms) {
                try {
                    const rng = new PRNG.PRNG(seed, algo);
                    
                    // Basic functionality
                    const values = [];
                    for (let i = 0; i < 5; i++) values.push(rng.random().toFixed(4));
                    
                    // Reproducibility
                    const rng2 = new PRNG.PRNG(seed, algo);
                    let matches = true;
                    rng.reset();
                    for (let i = 0; i < 100; i++) {
                        if (rng.random() !== rng2.random()) matches = false;
                    }
                    
                    allPassed &= assert(container, matches, 
                        `${algo.padEnd(12)} reproducible [${values.slice(0, 3).join(', ')}...]`);
                        
                } catch (e) {
                    log(container, `‚ùå ${algo}: ${e.message}`, 'fail');
                    allPassed = false;
                }
            }
            
            setStatus('algos', allPassed);
        }
        
        function testVisualizations() {
            const section = document.createElement('div');
            section.className = 'test-section visual-section';
            section.innerHTML = `
                <div class="section-header">
                    <h2>üìà Visual Tests</h2>
                    <span class="section-status status-pass">VISUAL</span>
                </div>
                <div class="visual-grid">
                    <div class="visual-item">
                        <h3>Uniform Distribution</h3>
                        <div class="histogram" id="uniformHist"></div>
                    </div>
                    <div class="visual-item">
                        <h3>Normal Distribution</h3>
                        <div class="histogram" id="normalHist"></div>
                    </div>
                    <div class="visual-item">
                        <h3>2D Point Distribution</h3>
                        <canvas id="pointCanvas" width="200" height="200"></canvas>
                    </div>
                    <div class="visual-item">
                        <h3>2D Noise</h3>
                        <canvas id="noiseCanvas" width="200" height="200"></canvas>
                    </div>
                </div>
            `;
            document.getElementById('testGrid').appendChild(section);
            
            const seed = getSeed();
            const algo = getAlgorithm();
            const rng = new PRNG.PRNG(seed, algo);
            
            // Uniform histogram
            const uniformBins = new Array(20).fill(0);
            for (let i = 0; i < 10000; i++) {
                const bin = Math.floor(rng.random() * 20);
                uniformBins[bin]++;
            }
            const maxUniform = Math.max(...uniformBins);
            const uniformHist = document.getElementById('uniformHist');
            uniformBins.forEach(count => {
                const bar = document.createElement('div');
                bar.className = 'histogram-bar';
                bar.style.height = (count / maxUniform * 130) + 'px';
                uniformHist.appendChild(bar);
            });
            
            // Normal histogram
            const normalBins = new Array(20).fill(0);
            for (let i = 0; i < 10000; i++) {
                const v = rng.normal(0, 1);
                const bin = Math.floor((v + 4) / 0.4);
                if (bin >= 0 && bin < 20) normalBins[bin]++;
            }
            const maxNormal = Math.max(...normalBins);
            const normalHist = document.getElementById('normalHist');
            normalBins.forEach(count => {
                const bar = document.createElement('div');
                bar.className = 'histogram-bar';
                bar.style.height = (count / maxNormal * 130) + 'px';
                bar.style.background = '#a371f7';
                normalHist.appendChild(bar);
            });
            
            // Point distribution
            const pointCanvas = document.getElementById('pointCanvas');
            const pctx = pointCanvas.getContext('2d');
            pctx.fillStyle = '#58a6ff';
            for (let i = 0; i < 500; i++) {
                const p = rng.pointInCircle(90);
                pctx.beginPath();
                pctx.arc(100 + p.x, 100 + p.y, 2, 0, Math.PI * 2);
                pctx.fill();
            }
            
            // Noise visualization
            const noiseCanvas = document.getElementById('noiseCanvas');
            const nctx = noiseCanvas.getContext('2d');
            const noise = new PRNG.Noise.SimplexNoise(seed);
            const imageData = nctx.createImageData(200, 200);
            
            for (let y = 0; y < 200; y++) {
                for (let x = 0; x < 200; x++) {
                    const v = noise.fbm(x * 0.02, y * 0.02, null, 4, 2.0, 0.5);
                    const c = Math.floor((v + 1) / 2 * 255);
                    const i = (y * 200 + x) * 4;
                    imageData.data[i] = c;
                    imageData.data[i + 1] = c;
                    imageData.data[i + 2] = c;
                    imageData.data[i + 3] = 255;
                }
            }
            nctx.putImageData(imageData, 0, 0);
        }
        
        function runAllTests() {
            clearResults();
            
            testBasicGeneration();
            testReproducibility();
            testStateManagement();
            testDistributions();
            testArrayUtilities();
            testGeometric();
            testSpecialGenerators();
            testNoise();
            testAllAlgorithms();
            testVisualizations();
            
            // Show summary
            const summary = document.getElementById('summary');
            summary.style.display = 'block';
            document.getElementById('passCount').textContent = testResults.passed;
            document.getElementById('failCount').textContent = testResults.failed;
            document.getElementById('totalCount').textContent = testResults.passed + testResults.failed;
        }
        
        // Auto-run on load
        window.onload = runAllTests;
    </script>
</body>
</html>
